% Compiler Construction 2016, Series 1
% C Rackwitz, Wanja Hentze, Max, Jonathan Neuschäfer (334424)


## Exercise 1
<!--
   Give a complete list of the symbol classes and corresponding tokens
   needed for the lexical analysis of our programming language WHILE. Recall
   that WHILE captures (integer) variable declarations, assignments, arithmetic
   operations, conditional branches, loops, basic I/O (read and write) and
   Java-style comments.
-->

### (a)

symbol class       | token      | example
-------------------+------------+--------------------
White space        | space      | (space,)
keyword            | keyword    | (keyword,"int")
identifier         | ident      | (ident, "i")
comment            | comment    | (comment)
number literal     | number     | (number, "1.1e+20")
string literal     | string     | (string, "Hello World")
binary operator    | binop      | (binop, "+")
unary operator     | unop       | (unop, "++")
left parenthesis   | leftparen  | (leftparen,)
right parenthesis  | rightparen | (rightparen,)
left curly brace   | leftbrace  | (leftbrace,)
right curly brace  | rightbrace | (rightbrace,)
semicolon          | semicolon  | (semicolon,)
assignment op. (=) | assign     | (assign,)
read/write


/∗ A random w a l k ∗/
int x = 1 0 ;
int s = 0 ;
while ( x > 0 ) {
	int b = r e a d ( ) % 2 ; // randomness by u s e r i n p u t
	if (b == 1) {
		x = x + 1;
	} else {
		x = x − 1;
	}
	s++;
}
write ( " I stopped walking a f t e r : " ) ;
write ( s ) ;
write (" steps " ) ;

### (b)

	if (b == 1) {
		x = x + 1;
	} else {
		x = x − 1;
	}

lexeme          | symbol
----------------+--------
"`\t`"          | (space,)
"`if`"          | (keyword, "if")
"` `"           | (space,)
"`(`"           | (leftparen,)
"`b`"           | (ident, "b")
"` `"           | (space,)
"`==`"          | (binop, "==")
"` `"           | (space,)
"`1`"           | (number, "1")
"`)`"           | (rightparen,)
"` `"           | (space,)
"`{`"           | (leftbrace,)
"`\n\t\t`"      | (space,)
"`x`"           | (ident, "x")
"` `"           | (space,)
"`=`"           | (assign,)
"` `"           | (space,)
"`x`"           | (ident, "x")
"` `"           | (space,)
"`+`"           | (binop, "+")
"`1`"           | (number, "1")
"`;`"           | (semicolon,)
"`\n\t`"        | (space,)
"`}`            | (rightbrace,)
"` `"           | (space,)
"`else`"        | (keyword, "else")
"` `"           | (space,)
"`{`"           | (leftbrace,)
"`\n\t\t`"      | (space,)
"`x`"           | (ident, "x")
"` `"           | (space,)
"`=`"           | (assign,)
"` `"           | (space,)
"`x`"           | (ident, "x")
"` `"           | (space,)
"`-`"           | (binop, "-")
"`1`"           | (number, "1")
"`;`"           | (semicolon,)
"`\n\t`"        | (space,)
"`}`            | (rightbrace,)
"`\n`"          | (space,)


## Exercise 2

### (a)

$(`//` \cdot (all characters but \n and \r)^+ | (`/*` \cdot (all characters but `*` | `*` \cdot (all characters but `/`))))$

<!-- ^ TODO: review -->

### (b)

<!--
(b) Provide a regular expression capturing numbers in scientific notation, e.g. -17.42e+23. To be more
precise, a number in scientific notation consists of a floating point number with an optional sign
followed by e followed by an integer number which may be preceded by an optional sign. In case
the floating point number is an integer, the dot may be omitted. Furthermore, if it is less than one,
an initial zero may be omitted. Thus, .3e-8 and +42e0 are valid numbers in scientific notation.
-->

$(`+` | `-` | ε) \cdot \\
 ( (`0`|\dots|`9`)^+ | (`0`|\dots|`9`)^+`.`(`0`|\dots|`9`)^\* | `.`(0|\dots|9)^+ ) \cdot \\
 `e` \cdot (`+`|`-`|ε) (`0`|\dots|`9`)^+$


### (c)

<!-- erst (b) machen. -->
<!-- dot -->

### (d)

<!-- NFA-Lauf -->

### (e)

Transformations:

1. L(r[n,m]) = r \dot r[n-1,m-1]
2. r[0,a] = r[0,a-1] \cdot r[a,a]
3. r[a,a] = r^a = $r \cdot \dots \cdot r \underbrace{a times}$
4. Combining 1, 2 and 3, we can see that every RE $r[n,m]$, where $r$ does not
   contain any repetition operators, can be transformed into a RE that does not
   contain any repetition operators itself.
5. By induction, every RE that contains repetition operators can be transformed
   into an RE that does not contain repetition operators.

Proof: ...
