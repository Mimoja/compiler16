% Compiler Construction 2016, Series 1
% C Rackwitz, Wanja Hentze, Maximilian Schander(331410), Jonathan Neusch√§fer (334424)


## Exercise 1

### (a)

symbol class       | token      | example
-------------------+------------+--------------------
White space        | space      | (space,)
keyword            | keyword    | (keyword,"int")
identifier         | ident      | (ident, "i")
comment            | comment    | (comment)
number literal     | number     | (number, "1.1e+20")
string literal     | string     | (string, "Hello World")
binary operator    | binop      | (binop, "+")
unary operator     | unop       | (unop, "++")
left parenthesis   | leftparen  | (leftparen,)
right parenthesis  | rightparen | (rightparen,)
left curly brace   | leftbrace  | (leftbrace,)
right curly brace  | rightbrace | (rightbrace,)
semicolon          | semicolon  | (semicolon,)
assignment op. (=) | assign     | (assign,)

Note that "read" and "write" are scanned as identifiers.


### (b)

lexeme          | symbol
----------------+--------------------
"`\t`"          | (space,)
"`if`"          | (keyword, "if")
"`_`"           | (space,)
"`(`"           | (leftparen,)
"`b`"           | (ident, "b")
"`_`"           | (space,)
"`==`"          | (binop, "==")
"`_`"           | (space,)
"`1`"           | (number, "1")
"`)`"           | (rightparen,)
"`_`"           | (space,)
"`{`"           | (leftbrace,)
"`\n\t\t`"      | (space,)
"`x`"           | (ident, "x")
"`_`"           | (space,)
"`=`"           | (assign,)
"`_`"           | (space,)
"`x`"           | (ident, "x")
"`_`"           | (space,)
"`+`"           | (binop, "+")
"`1`"           | (number, "1")
"`;`"           | (semicolon,)
"`\n\t`"        | (space,)
"`}`"           | (rightbrace,)
"`_`"           | (space,)
"`else`"        | (keyword, "else")
"`_`"           | (space,)
"`{`"           | (leftbrace,)
"`\n\t\t`"      | (space,)
"`x`"           | (ident, "x")
"`_`"           | (space,)
"`=`"           | (assign,)
"`_`"           | (space,)
"`x`"           | (ident, "x")
"`_`"           | (space,)
"`-`"           | (binop, "-")
"`1`"           | (number, "1")
"`;`"           | (semicolon,)
"`\n\t`"        | (space,)
"`}`"           | (rightbrace,)
"`\n`"          | (space,)

Note that spaces have been rendered as underscores due to
typesetting problems.

## Exercise 2

### (a)

$(`//` \cdot (all characters but \\n and \\r)^+ | (`/*` \cdot (all characters but `*` | `*` \cdot (all characters but `/`))))$

<!-- ^ TODO: review -->

### (b)

$(+ | - | \varepsilon) ((0 | ... | 9)^+ | (0 | ... | 9)^+ . (0 | ... | 9)^* | .(0 | ... | 9)) (\varepsilon | e (+|-|\varepsilon) (0| ... | 9))$


### (c)

<!-- erst (b) machen. -->
<!-- dot -->

### (d)

<!-- NFA-Lauf -->

### (e)


First we define the repetition operator formally:

	r[n,m] = \{ r^k | k \in \mathbb{N}, n <= k <= m \}

We can see that the repetition operator defines a regular language.

The following equalities hold intuitively:

	r[n+1,m+1] = \{ r^{k+1} | k+1 \in \mathbb{N}, n+1 <= k+1 <= m+1 \} = \{ r r^k | k \in \mathbb{N}, n <= k <= m \} = r r[n,m]

	r[0,n+1] = \( \epsilon | r \) r[0,n]

	r[0,0] = \epsilon

Using these operations inductively, the repetition operator can be reduced to regular expressions.
